面向对象(Java/C++/C#)
面向对象思想:
	1.面相对象是一种常见的思想，符合人们的思考习惯
	2.面向对象的出现将复杂的事情变得简单化
	3.面向对象的出现将我们的身份由执行者变成指挥者
	4.面向对象的重点有两个:
		a.有没有这个对象
		b.对象里具不具备这个功能

面向对象开发
	就是不断创建对象,使用对象,指挥对象做事情，
	有对象就找这个对象做事情,没有对象就自己创建一个对象
	,使其拥有这样的功能,其他人也可以使用这个对象
	
面向对象设计
	维护和管理对象之间的关系
	
面向对象特性
	1.封装
	2.继承
	3.多态
	4.抽象
	
类和对象的关系：
	在Java语言中对现实生活中的事物进行描述，通过类的形式来体现
	对有事物的描述我们通常只关注两个方面:一个是属性,一个是行为(功能，方法)
	只要明确该类事物的属性和行为定义在类中即可
	
	
类:
	某一类事物的描述(属性,行为)
	一个.java文件中最多只能有一个public修饰的类
	public修饰的类类名必须与.java文件的文件名一致
对象:
	该类事物的实例(实体),在Java中通过new来创建
	一个对象可以被多个变量所引用

成员变量和局部变量的区别:
	1.成员变量定义在类中，整个类都可以访问、
	局部变量定义在方法,语句中(for循环)，局部代码块中,
	只在所属的区域有效
	2.成员变量存在于堆内存的对象中
	局部变量存在于栈内存的方法中(方法运行的时候会在栈内存中加载)
	3.成员变量随着对象的创建而存在,随着对象的消失而消失
	局部变量随着所属区域的执行而存在，随着所属区域的结束而释放
	4.成员变量有默认的初始化值
	局部变量没有默认的初始化值

private:
	私有的,是权限修饰符,用于修饰成员,
	私有的内容只在本类中有效
	
封装:
	将属性私有化,对外提供公共的访问方法	
	
构造方法(构造器:constructor):
	1.构造器的名称与类名相同
	2.不用定义返回值类型
	3.没有具体的返回值
	作用:
		给对象进行初始化
	注意:
		1.默认构造器的特点:	
			如果一个类中没有定义过构造器就会有一个默认的		
			无参构造器,如果定义过构造器,那么默认的无参构造器
			就不存在了
		2.多个构造器是以重载的形式来体现的
		
重载:方法名相同,参数列表不同
	
this关键字:
	1.当成员变量和局部变量重名时候，可以使用关键字this来区分
	this:代表当前对象,既是所在方法所属对象的引用
	哪个对象调用了this所在的方法,this就代表哪个对象
	2.this还可以在构造器中调用构造器
	只能定义在构造器代码体的第一行,语法规则

static关键字:
	1.static是一个修饰符,用于修饰成员
	2.static修饰的成员被所有的对象所共享
	3.static优先于对象而存在,因为static修饰的成员
	随着类的加载就已经存在了
	4.static修饰的成员多了种调用方式,可以直接被
	类名.静态成员的方式调用
	5.static修饰的数据是共享数据,对象中存储的数据
	是特有数据
	
静态变量和成员变量的区别:
	1.两个变量的生命周期不同
		成员变量随着对象的创建而存在,随着对象的回收而释放
		静态变量随着类的加载而存在,随着类的消失而消失
	2.调用方式不同
		成员变量只能被对象调用
		静态变量可以被对象调用也可以被类名调用
	3.别名不同
		成员变量也称作是实例变量
		静态变量也称作是类变量
	4.数据的存储位置不同
		成员变量数据存储在堆内存的对象中，所以也叫做对象的
		特有数据
		静态变量数据存储在方法区中的静态方法区当中

静态什么时候用?
	1.静态变量
		当分析对象中所具备的成员变量的值都是相同的,这时
		这个成员可以被静态修饰,只要数据在对象中是不同的,
		就是对象的特有数据,必须存储在对象中,是非静态的,
		如果是相同的数据,对象不需要做修改,只需要使用即可,
		不需要存储在对象中,定义成静态的
	2.静态方法
		方法是否用静态修饰,就参考一点,该方法功能是否有
		访问到对象中的特有数据,如果有,就定义成非静态的,
		如果没有,就可以定义成静态的
		
		a.静态方法中不能调用非静态的成员变量
		因为静态方法随着类的加载就已经存在了
		成员变量随着对象的创建而存在，调用方法
	 	的时候还没有name
		b.静态方法中不能使用this关键字或者super关键字
	
静态代码块(定义在类中)
	static{
		
	}
	随着类的加载而执行,并且只执行一次
	作用:
		可以给类进行初始化
	
构造代码块(定义在类中)
	{
	
	}
	作用:构造代码块,用于给全体对象进行初始化
	
在一个类中静态代码块,构造代码块,构造器,
它们执行的先后顺序是什么?
静态代码块,构造代码块,构造器

继承(extends)
	1.提高了代码的复用性
	2.让类与类之间产生了关系,给第三个特征多态提供了前提

Java中的单继承和多继承
	Java支持单继承,不直接支持多继承,但是对C++中的多继承
	机制进行了改良
	单继承:一个子类只能有一个直接父类
	多继承:一个子类可以有多个直接父类(Java不允许)
	Java支持多层(多重)继承
	
什么时候定义继承
	当类与类之间存在所属关系时,就定义继承,x是y的一种,
	X extends Y

在子父类中,成员的特点体现
	1.成员变量:
		当本类中成员变量和局部变量重名时用this来区分
		当子父类中成员变量重名时用super来区分
		this:代表的是一个本类对象的引用
		super:代表的是一个父类的空间
	
	2.成员方法:
		当子父类中出现成员方法一模一样的情况,会运行子类的方法
		这种现象,称为覆盖操作,也称为方法的重写,这是方法在子父
		类中的特性
		重载(overload):在同一个类中
		重写(override):在子父类中,子类重写父类的方法(重写也叫做覆盖)
	
	重写的注意事项:
		1.子类重写父类的方法时,子类的权限必须要大于等于
		父类的权限
		2.静态只能覆盖静态或者被静态覆盖
	
	3.构造方法
		子类继承了父类,获取父类的内容(属性),所以在使用
		父类的内容之前,要先看父类是如何对自己的内容进行
		初始化的	,所以在子类构造对象时,必须访问父类的构造器
		为了完成这个功能,就在子类的构造器中加入了super语句
		如果父类中没有定义空参数的构造器,那么子类的构造器必须
		要用super明确调用父类中的有参构造器
		
			父类中没有无参构造器,子类中使用
			super调用父类的有参构造器,在()指定
			参数即可
		
			super必须定义在第一行,语法规则
			
		同时子类构造器中如果使用this调用本来的构造器,那么super
		就没用了,因为super和this都只能够定义在第一行,所以只能
		有一个,但是可以保证的是,子类中肯定会有其他构造器访问
		父类构造器
	
对象在内存中的实例化过程:
	Person p = new Person();
	1.JVM会读取指定路径下的Person.class文件,并加载到内存当中
	并会先加载Person的父类(如果有直接父类的情况下)
	2.在堆内存中开辟空间,分配地址
	3.并在对象空间中,对对象的属性进行默认初始化
	4.调用对应的构造器进行初始化
	5.在构造器中,第一行会先父类的构造器进行初始化
	6.父类初始化完毕之后,再对子类的属性进行显示初始化
	7.显示初始化完毕之后,再进行子类构造器的特定初始化
	8.初始化结束后,将地址值赋值给引用变量
	
final关键字:
	final是一个修饰符,可以修饰类,方法,变量
		final修饰的类不可以被继承(Math/String/Integer...)
		final修饰的方法不可以被覆盖(重写)
		final修饰的变量是常量,只能赋值一次
		一般用final static 修饰常量
		
抽象类 abstract

抽象类特点:
	1.方法只有声明没有实现时(没有方法体),该方法就是抽象方法，
	需要被abstract修饰,抽象方法必须定义在抽象类中,该类也需要
	被abstract修饰
	2.抽象类不可以被实例化(不可被new)
	因为调用抽象方法没有任何意义
	3.抽象类必须由其子类覆盖了所有的抽象方法后,该子类才可以
	实例化,否则这个子类还是一个抽象类
	4.抽象类和抽象方法非常适合做"系统的分析和设计工具"

1.抽象类中有构造器,用于给子类的对象初始化
2.抽象类中可以不定义抽象方法
3.abstract 关键字不可以和哪些关键字共存?
	private 抽象方法需要被覆盖
	static 静态方法可以直接通过类名调用,调用抽象方法没有意义
	final final修饰的方法不可以被覆盖
4.抽象类一定是父类,需要子类覆盖方法后才能使用
5.抽象类一般类异同:
	相同点:
		抽象类和一般类都是用来描述事物的,都在内部定义了成员
	不同点：
		a.一般类有足有的信息描述事物
		抽象类描述事物的信息可能不足
		b.一般类中不能定义抽象方法,只能定义非抽象方法
		抽象类中可以定义抽象法,同时也能定义非抽象方法
		c.一般类可以被实例化
		抽象类不可以被实例化
	
接口 interface

	接口定义格式:interface{}
	
	接口中的成员修饰符都是固定的:
	
	成员常量:public static final
	
	成员方法:public abstract
	
	类和类之间是继承关系,类和接口之间是实现(implements)关系
	
	接口不可以被实例化,只能由实现了接口的子类并覆盖了接口中所有的
	抽象方法,该子类才可以实例化,否则这个子类就是一个抽象类
	
	接口的出现将"多继承"通过另外一种形式体现出来,既"多实现"
	
	接口的特点:
		1.接口是一个特殊的抽象类(纯抽象类)
		2.接口是程序的功能扩展
		3.接口的出现降低了耦合性
		耦合性:也称为块间联系,指软件系统结构中各模块间相互
		联系紧密程度的一种度量
		内聚性:又称为块内联系,指的是一个模块内部各个元素
		彼此结合的紧密程度的度量
		4.接口可以用来多实现
		5.类与接口之间是实现关系,而且一个类可以继承一个
		类的同时实现多个接口
		6.接口的属性默认是常量,而且是public static final修饰的
		7.接口中的方法一定是public abstract修饰的(默认的,可以不写)
		8.接口和接口之间是可以有多继承关系
		9.接口中没有构造器
		
接口和抽象类的异同
	相同点:
		都是不断向上抽取而来的
	不同点:
		1.抽象类需要被继承,而且只能单继承,接口需要被实现,而且
		可以多实现
		2.抽象类中可以定义抽象方法和非抽象方法,子类继承后
		可以直接使用非抽象方法,接口中只能定义抽象方法,
		必须由子类去实现
		3.抽象类的继承,是is a关系,在定义该体系的基本共性内容
		接口的实现,是like a关系,在定义体系的额外功能
	
访问控制修饰符(权限修饰符,修饰java类,属性,方法的访问可见范围)
				  类内         包内      子类       任意
	public			√			√ 		  √			 √
	proteceted		√	   		√		  √
	default			√			√			
	private			√			
	
	private:私有的,仅仅在类的内部可见
	public:公有的,任意位置可见(类内部,同一个包中,子类,和其他地方)
	protected:受保护的,在同一个包和子类中可见
	default:默认的,什么都不写,在同一个包中可见
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	