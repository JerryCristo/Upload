面向对象(Java/C++/C#)
面向对象思想:
	1.面相对象是一种常见的思想，符合人们的思考习惯
	2.面向对象的出现将复杂的事情变得简单化
	3.面向对象的出现将我们的身份由执行者变成指挥者
	4.面向对象的重点有两个:
		a.有没有这个对象
		b.对象里具不具备这个功能

面向对象开发
	就是不断创建对象,使用对象,指挥对象做事情，
	有对象就找这个对象做事情,没有对象就自己创建一个对象
	,使其拥有这样的功能,其他人也可以使用这个对象
	
面向对象设计
	维护和管理对象之间的关系
	
面向对象特性
	1.封装
	2.继承
	3.多态
	4.抽象
	
类和对象的关系：
	在Java语言中对现实生活中的事物进行描述，通过类的形式来体现
	对有事物的描述我们通常只关注两个方面:一个是属性,一个是行为(功能，方法)
	只要明确该类事物的属性和行为定义在类中即可
	
	
类:
	某一类事物的描述(属性,行为)
	一个.java文件中最多只能有一个public修饰的类
	public修饰的类类名必须与.java文件的文件名一致
对象:
	该类事物的实例(实体),在Java中通过new来创建
	一个对象可以被多个变量所引用

成员变量和局部变量的区别:
	1.成员变量定义在类中，整个类都可以访问、
	局部变量定义在方法,语句中(for循环)，局部代码块中,
	只在所属的区域有效
	2.成员变量存在于堆内存的对象中
	局部变量存在于栈内存的方法中(方法运行的时候会在栈内存中加载)
	3.成员变量随着对象的创建而存在,随着对象的消失而消失
	局部变量随着所属区域的执行而存在，随着所属区域的结束而释放
	4.成员变量有默认的初始化值
	局部变量没有默认的初始化值

private:
	私有的,是权限修饰符,用于修饰成员,
	私有的内容只在本类中有效
	
封装:
	将属性私有化,对外提供公共的访问方法	
	
构造方法(构造器:constructor):
	1.构造器的名称与类名相同
	2.不用定义返回值类型
	3.没有具体的返回值
	作用:
		给对象进行初始化
	注意:
		1.默认构造器的特点:	
		
		2.多个构造器是以重载的形式来体现的
		
重载:方法名相同,参数列表不同
	
this关键字:
	1.当成员变量和局部变量重名时候，可以使用关键字this来区分
	this:代表当前对象,既是所在方法所属对象的引用
	哪个对象调用了this所在的方法,this就代表哪个对象
	2.this还可以在构造器中调用构造器
	只能定义在构造器代码体的第一行,语法规则

static关键字:
	1.static是一个修饰符,用于修饰成员
	2.static修饰的成员被所有的对象所共享
	3.static优先于对象而存在,因为static修饰的成员
	随着类的加载就已经存在了
	4.static修饰的成员多了种调用方式,可以直接被
	类名.静态成员的方式调用
	5.static修饰的数据是共享数据,对象中存储的数据
	是特有数据
	
静态变量和成员变量的区别:
	1.两个变量的生命周期不同
		成员变量随着对象的创建而存在,随着对象的回收而释放
		静态变量随着类的加载而存在,随着类的消失而消失
	2.调用方式不同
		成员变量只能被对象调用
		静态变量可以被对象调用也可以被类名调用
	3.别名不同
		成员变量也称作是实例变量
		静态变量也称作是类变量
	4.数据的存储位置不同
		成员变量数据存储在堆内存的对象中，所以也叫做对象的
		特有数据
		静态变量数据存储在方法区中的静态方法区当中

静态什么时候用?
	1.静态变量
		当分析对象中所具备的成员变量的值都是相同的,这时
		这个成员可以被静态修饰,只要数据在对象中是不同的,
		就是对象的特有数据,必须存储在对象中,是非静态的,
		如果是相同的数据,对象不需要做修改,只需要使用即可,
		不需要存储在对象中,定义成静态的
	2.静态方法
		方法是否用静态修饰,就参考一点,该方法功能是否有
		访问到对象中的特有数据,如果有,就定义成非静态的,
		如果没有,就可以定义成静态的
	
静态代码块(定义在类中)
	static{
		
	}
	随着类的加载而执行,并且只执行一次
	作用:
		可以给类进行初始化
	
构造代码块(定义在类中)
	{
	
	}
	作用:构造代码块,用于给全体对象进行初始化
	
在一个类中静态代码块,构造代码块,构造器,
它们执行的先后顺序是什么?
静态代码块,构造代码块,构造器

继承(extends)
	1.提高了代码的复用性
	2.让类与类之间产生了关系,给第三个特征多态提供了前提

Java中的单继承和多继承
	Java支持单继承,不直接支持多继承,但是对C++中的多继承
	机制进行了改良
	单继承:一个子类只能有一个直接父类
	多继承:一个子类可以有多个直接父类(Java不允许)
	Java支持多层(多重)继承
	
什么时候定义继承
	当类与类之间存在所属关系时,就定义继承,x是y的一种,
	X extends Y

在子父类中,成员的特点体现
	1.成员变量:
		当本类中成员变量和局部变量重名时用this来区分
		当子父类中成员变量重名时用super来区分
		this:代表的是一个本类对象的引用
		super:代表的是一个父类的空间
	
	2.成员方法:
		当子父类中出现成员方法一模一样的情况,会运行子类的方法
		这种现象,称为覆盖操作,也称为方法的重写,这是方法在子父
		类中的特性
		重载(overload):在同一个类中
		重写(override):在子父类中,子类重写父类的方法(重写也叫做覆盖)
	
	重写的注意事项:
		1.子类重写父类的方法时,子类的权限必须要大于等于
		父类的权限
		2.静态只能覆盖静态或者被静态覆盖
	
	3.构造方法
		子类继承了父类,获取父类的内容(属性),所以在使用
		父类的内容之前,要先看父类是如何对自己的内容进行
		初始化的	,所以在子类构造对象时,必须访问父类的构造器
		为了完成这个功能,就在子类的构造器中加入了super语句
		如果父类中没有定义空参数的构造器,那么子类的构造器必须
		要用super明确调用父类中的有参构造器
		super必须定义在第一行,语法规则
		同时子类构造器中如果使用this调用本来的构造器,那么super
		就没用了,因为super和this都只能够定义在第一行,所以只能
		有一个,但是可以保证的是,子类中肯定会有其他构造器访问
		父类构造器
	
对象在内存中的实例化过程:
	Person p = new Person();
	1.JVM会读取指定路径下的Person.class文件,并加载到内存当中
	并会先加载Person的父类(如果有直接父类的情况下)
	2.在堆内存中开辟空间,分配地址
	3.并在对象空间中,对对象的属性进行默认初始化
	4.调用对应的构造器进行初始化
	5.在构造器中,第一行会先父类的构造器进行初始化
	6.父类初始化完毕之后,再对子类的属性进行显示初始化
	7.显示初始化完毕之后,再进行子类构造器的特定初始化
	8.初始化结束后,将地址值赋值给引用变量
	
	
	
	
	
	
	
	
	
	
	
	
	
	
